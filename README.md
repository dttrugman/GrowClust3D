# GrowClust3D
This repository hosts a Julia implementation of the GrowClust program for relative relocation of earthquake hypocenters based on waveform cross-correlation data. The vision for this program is to provide more flexibility and 3D velocity model capabilities than the original Fortran90 source code. Complete documentation is still a work in progress but here: https://github.com/dttrugman/GrowClust3D/wiki/Documentation. We are planning a manuscript describing this new package for publication in *Seismological Research Letters*. Citation details will be updated at that time.

---

The (unregistered) package can be installed using the Julia Pkg manager:

` pkg> add https://github.com/dttrugman/GrowClust3D`

[Note, to download a local copy of this repository, try `git clone https://github.com/dttrugman/GrowClust3D`.]

Once installed, please do run the test set that checks your installation by running a suite of test problems:

` pkg> test GrowClust3D`

---

The `examples/` directory has two different Julia (.jl) "run/driver" scripts: `run_growclust3D.jl` as a reference example for typical usage on a single processor, and `run_growclust3D-MP.jl` which is similar in spirit but designed for multiprocessing on multiple cores. These two .jl scripts can be copied and reused as examples for any generic GrowClust3D problem with little/no modification.

The primary way to tailor GrowClust3D to your dataset is by modifying the input files. With this in mind, in `examples/` there are four different example input (.inp) files related to the Spanish Springs, Nevada earthquake sequence. Any of the input files can be paired with either of the two run scripts. The example input files are summarized as follows:

1. `example.trace1D.inp`: example raytracing a 1D velocity model
2. `example.nllgrid1D.inp`: example using precomputed (NonLinLoc) 1D travel time grid
3. `example.nllgrid3D.inp`: example using precomputed (NonLinLoc) 3D travel time grid
4. `example.nboot100.inp`: example with bootstrapping (e.g. to test parallelization)

Example 1 uses internal ray-tracing codes and emulates the classic GrowClust example from the original Trugman and Shearer (2017) publication. Examples 2 and 3 use 1D and (quasi)-3D travel-time grids generated by NonLinLoc (https://github.com/alomax/NonLinLoc) from an equivalent velocity model. Example 4 is identical to Example 1 but with bootstrapping turned on. This is useful for testing the parallelization described below.

The central difference between the two example run (.jl) scripts is in their mode of parallelization. The `run_growclust3D.jl` script can use multithreading on a single computational core to accelerate bootstrap uncertainty analysis. This is useful but limited to the number of threads accessible. The `run_growclust3D-MP.jl` script can use multiprocessing to further accelerate these calculations in cases where multiple cores are available (e.g., runs on a computing cluster). Generally, if sufficient resources are available, multiprocessing will be faster than multithreading (especially for large datasets) due to memory considerations. For most use cases, the computational overhead in transferring data to the additional processors is negligible compared to additional compute power. Below are some example use cases of the codes:

Simple examples without bootstrapping (good for testing): 

`julia run_growclust3D.jl example.serial1D.inp`

`julia run_growclust3D.jl example.nllgrid1D.inp`

`julia run_growclust3D.jl example.nllgrid3D.inp`

Multithreading and Multiprocessing examples: 

`julia -t4 run_growclust3D.jl example.nboot100.inp`

`julia -p10 run_growclust3D-MP.jl example.nboot100.inp`

In the first case above, I request 4 total threads. In the second, I request 10 processes (in addition to main). In either case, the user must request additional threads or processes to invoke parallelization.
